package me.liuwj.ktorm.entity

import me.liuwj.ktorm.database.prepareStatement
import me.liuwj.ktorm.dsl.AliasRemover
import me.liuwj.ktorm.expression.*
import me.liuwj.ktorm.schema.*

/**
 * 将给定的实体对象插入的表中，如果插入后有主键生成，会将生成的主键设置到实体对象中的相应属性，返回受影响的记录数
 */
@Suppress("UNCHECKED_CAST")
fun <E : Entity<E>> Table<E>.add(entity: E): Int {
    val assignments = findInsertColumns(entity).takeIf { it.isNotEmpty() } ?: return 0

    val expression = AliasRemover.visit(
        expr = InsertExpression(
            table = asExpression(),
            assignments = assignments.map { (col, argument) ->
                ColumnAssignmentExpression(
                    column = col.asExpression() as ColumnExpression<Any>,
                    expression = ArgumentExpression(argument, col.sqlType as SqlType<Any>)
                )
            }
        )
    )

    val useGeneratedKey = primaryKey?.binding != null && entity.getPrimaryKeyValue(this) == null

    expression.prepareStatement(autoGeneratedKeys = useGeneratedKey) { statement, logger ->
        val effects = statement.executeUpdate().also { logger.debug("Effects: {}", it) }

        if (useGeneratedKey) {
            statement.generatedKeys.use { rs ->
                if (rs.next()) {
                    val generatedKey = primaryKey?.sqlType?.getResult(rs, 1)
                    if (generatedKey != null) {
                        logger.debug("Generated Key: {}", generatedKey)
                        entity.setPrimaryKeyValue(this, generatedKey)
                    }
                }
            }
        }

        entity.impl.fromTable = this
        entity.discardChanges()
        return effects
    }
}

private fun Table<*>.findInsertColumns(entity: Entity<*>): Map<Column<*>, Any?> {
    val assignments = LinkedHashMap<Column<*>, Any?>()

    for (column in columns) {
        if (column is SimpleColumn && column.binding != null) {
            val value = entity.getColumnValue(column)
            if (value != null) {
                assignments[column] = value
            }
        }
    }

    return assignments
}

@Suppress("UNCHECKED_CAST")
internal fun EntityImpl.doFlushChanges(): Int {
    val fromTable = this.fromTable ?: kotlin.error("The entity is not associated with any table yet.")
    val primaryKey = fromTable.primaryKey ?: kotlin.error("Table ${fromTable.tableName} doesn't have a primary key.")
    val assignments = findChangedColumns(fromTable).takeIf { it.isNotEmpty() } ?: return 0

    val expression = AliasRemover.visit(
        expr = UpdateExpression(
            table = fromTable.asExpression(),
            assignments = assignments.map { (col, argument) ->
                ColumnAssignmentExpression(
                    column = col.asExpression() as ColumnExpression<Any>,
                    expression = ArgumentExpression(argument, col.sqlType as SqlType<Any>)
                )
            },
            where = BinaryExpression(
                type = BinaryExpressionType.EQUAL,
                left = primaryKey.asExpression(),
                right = ArgumentExpression(getPrimaryKeyValue(fromTable), primaryKey.sqlType as SqlType<Any>),
                sqlType = BooleanSqlType
            )
        )
    )

    expression.prepareStatement { statement, logger ->
        val effects =  statement.executeUpdate().also { logger.debug("Effects: {}", it) }
        discardChanges()
        return effects
    }
}

private fun EntityImpl.findChangedColumns(fromTable: Table<*>): Map<Column<*>, Any?> {
    val assignments = LinkedHashMap<Column<*>, Any?>()

    for (column in fromTable.columns) {
        val binding = column.binding?.takeIf { column is SimpleColumn } ?: continue

        when (binding) {
            is ReferenceBinding -> {
                if (binding.onProperty.name in changedProperties) {
                    val child = this[binding.onProperty.name] as Entity<*>?
                    assignments[column] = child?.getPrimaryKeyValue(binding.referenceTable)
                }
            }
            is NestedBinding -> {
                var anyChanged = false
                var curr: Any? = this

                for ((i, prop) in binding.withIndex()) {
                    check(curr is Entity<*>?)

                    val changed = if (curr == null) false else prop.name in curr.impl.changedProperties

                    if (changed && i > 0) {
                        check(curr != null)

                        if (curr.impl.fromTable != null && curr.getRoot() != this) {
                            val propPath = binding.subList(0, i + 1).joinToString(separator = ".", prefix = "this.") { it.name }
                            throw IllegalStateException("$propPath may be unexpectedly discarded after flushChanges, please save it to database first.")
                        }
                    }

                    anyChanged = anyChanged || changed
                    curr = curr?.get(prop.name)
                }

                if (anyChanged) {
                    assignments[column] = curr
                }
            }
        }
    }

    return assignments
}

private tailrec fun Entity<*>.getRoot(): Entity<*> {
    val parent = this.impl.parent
    if (parent == null) {
        return this
    } else {
        return parent.getRoot()
    }
}

internal fun EntityImpl.doDiscardChanges() {
    val fromTable = this.fromTable ?: kotlin.error("The entity is not associated with any table yet.")

    for (column in fromTable.columns) {
        val binding = column.binding?.takeIf { column is SimpleColumn } ?: continue

        when (binding) {
            is ReferenceBinding -> {
                changedProperties.remove(binding.onProperty.name)
            }
            is NestedBinding -> {
                var curr: Any? = this

                for (prop in binding) {
                    if (curr == null) {
                        break
                    }

                    check(curr is Entity<*>)
                    curr.impl.changedProperties.remove(prop.name)

                    curr = curr[prop.name]
                }
            }
        }
    }
}

@Suppress("UNCHECKED_CAST")
internal fun EntityImpl.doDelete(): Int {
    val fromTable = this.fromTable ?: kotlin.error("The entity is not associated with any table yet.")
    val primaryKey = fromTable.primaryKey ?: kotlin.error("Table ${fromTable.tableName} doesn't have a primary key.")

    val expression = AliasRemover.visit(
        expr = DeleteExpression(
            table = fromTable.asExpression(),
            where = BinaryExpression(
                type = BinaryExpressionType.EQUAL,
                left = primaryKey.asExpression(),
                right = ArgumentExpression(getPrimaryKeyValue(fromTable), primaryKey.sqlType as SqlType<Any>),
                sqlType = BooleanSqlType
            )
        )
    )

    expression.prepareStatement { statement, logger ->
        return statement.executeUpdate().also { logger.debug("Effects: {}", it) }
    }
}
