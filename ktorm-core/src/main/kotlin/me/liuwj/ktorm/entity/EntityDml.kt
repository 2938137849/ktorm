package me.liuwj.ktorm.entity

import me.liuwj.ktorm.database.prepareStatement
import me.liuwj.ktorm.dsl.AliasRemover
import me.liuwj.ktorm.expression.*
import me.liuwj.ktorm.schema.*

/**
 * 将给定的实体对象插入的表中，如果插入后有主键生成，会将生成的主键设置到实体对象中的相应属性，返回受影响的记录数
 */
@Suppress("UNCHECKED_CAST")
fun <E : Entity<E>> Table<E>.add(entity: E): Int {
    val assignments = findInsertColumns(entity).takeIf { it.isNotEmpty() } ?: return 0

    val expression = AliasRemover.visit(
        expr = InsertExpression(
            table = asExpression(),
            assignments = assignments.map { (col, argument) ->
                ColumnAssignmentExpression(
                    column = col.asExpression() as ColumnExpression<Any>,
                    expression = ArgumentExpression(argument, col.sqlType as SqlType<Any>)
                )
            }
        )
    )

    val useGeneratedKey = primaryKey?.binding != null && entity.getPrimaryKeyValue(this) == null

    expression.prepareStatement(autoGeneratedKeys = useGeneratedKey) { statement, logger ->
        val effects = statement.executeUpdate().also { logger.debug("Effects: {}", it) }

        if (useGeneratedKey) {
            statement.generatedKeys.use { rs ->
                if (rs.next()) {
                    val generatedKey = primaryKey?.sqlType?.getResult(rs, 1)
                    if (generatedKey != null) {
                        logger.debug("Generated Key: {}", generatedKey)
                        entity.setPrimaryKeyValue(this, generatedKey)
                    }
                }
            }
        }

        entity.impl.fromTable = this
        entity.discardChanges()
        return effects
    }
}

private fun Table<*>.findInsertColumns(entity: Entity<*>): Map<Column<*>, Any?> {
    val assignments = LinkedHashMap<Column<*>, Any?>()

    for (column in columns) {
        val binding = column.binding?.takeIf { column is SimpleColumn } ?: continue

        when (binding) {
            is SimpleBinding -> {
                entity[binding.property.name]?.let { assignments[column] = it }
            }
            is NestedBinding -> {
                val child = entity[binding.property1.name] as Entity<*>?
                child?.get(binding.property2.name)?.let { assignments[column] = it }
            }
            is TripleNestedBinding -> {
                val child = entity[binding.property1.name] as Entity<*>?
                val grandChild = child?.get(binding.property2.name) as Entity<*>?
                grandChild?.get(binding.property3.name)?.let { assignments[column] = it }
            }
            is ReferenceBinding -> {
                val child = entity[binding.onProperty.name] as Entity<*>?
                child?.getPrimaryKeyValue(binding.referenceTable)?.let { assignments[column] = it }
            }
        }
    }

    return assignments
}

@Suppress("UNCHECKED_CAST")
internal fun EntityImpl.doFlushChanges(): Int {
    val fromTable = this.fromTable ?: kotlin.error("The entity is not associated with any table yet.")
    val primaryKey = fromTable.primaryKey ?: kotlin.error("Table ${fromTable.tableName} dosen't have a primary key.")
    val assignments = findChangedColumns(fromTable).takeIf { it.isNotEmpty() } ?: return 0

    val expression = AliasRemover.visit(
        expr = UpdateExpression(
            table = fromTable.asExpression(),
            assignments = assignments.map { (col, argument) ->
                ColumnAssignmentExpression(
                    column = col.asExpression() as ColumnExpression<Any>,
                    expression = ArgumentExpression(argument, col.sqlType as SqlType<Any>)
                )
            },
            where = BinaryExpression(
                type = BinaryExpressionType.EQUAL,
                left = primaryKey.asExpression(),
                right = ArgumentExpression(getPrimaryKeyValue(fromTable), primaryKey.sqlType as SqlType<Any>),
                sqlType = BooleanSqlType
            )
        )
    )

    expression.prepareStatement { statement, logger ->
        val effects =  statement.executeUpdate().also { logger.debug("Effects: {}", it) }
        discardChanges()
        return effects
    }
}

private fun EntityImpl.findChangedColumns(fromTable: Table<*>): Map<Column<*>, Any?> {
    val assignments = LinkedHashMap<Column<*>, Any?>()

    for (column in fromTable.columns) {
        val binding = column.binding?.takeIf { column is SimpleColumn } ?: continue

        when (binding) {
            is SimpleBinding -> {
                if (binding.property.name in changedProperties) {
                    assignments[column] = this[binding.property.name]
                }
            }
            is NestedBinding -> {
                val child = this[binding.property1.name] as Entity<*>?
                val childChanges = child?.impl?.changedProperties ?: emptySet<String>()

                if (binding.property1.name in changedProperties || binding.property2.name in childChanges) {
                    assignments[column] = child?.get(binding.property2.name)
                }
            }
            is TripleNestedBinding -> {
                val child = this[binding.property1.name] as Entity<*>?
                val childChanges = child?.impl?.changedProperties ?: emptySet<String>()

                val grandChild = child?.get(binding.property2.name) as Entity<*>?
                val grandChildChanges = grandChild?.impl?.changedProperties ?: emptySet<String>()

                if (binding.property1.name in changedProperties || binding.property2.name in childChanges || binding.property3.name in grandChildChanges) {
                    assignments[column] = grandChild?.get(binding.property3.name)
                }
            }
            is ReferenceBinding -> {
                if (binding.onProperty.name in changedProperties) {
                    val child = this[binding.onProperty.name] as Entity<*>?
                    assignments[column] = child?.getPrimaryKeyValue(binding.referenceTable)
                }
            }
        }
    }

    return assignments
}

@Suppress("UNCHECKED_CAST")
internal fun EntityImpl.doDelete(): Int {
    val fromTable = this.fromTable ?: kotlin.error("The entity is not associated with any table yet.")
    val primaryKey = fromTable.primaryKey ?: kotlin.error("Table ${fromTable.tableName} dosen't have a primary key.")

    val expression = AliasRemover.visit(
        expr = DeleteExpression(
            table = fromTable.asExpression(),
            where = BinaryExpression(
                type = BinaryExpressionType.EQUAL,
                left = primaryKey.asExpression(),
                right = ArgumentExpression(getPrimaryKeyValue(fromTable), primaryKey.sqlType as SqlType<Any>),
                sqlType = BooleanSqlType
            )
        )
    )

    expression.prepareStatement { statement, logger ->
        return statement.executeUpdate().also { logger.debug("Effects: {}", it) }
    }
}
